
gnome3では、gdm後にxsession経由か、gdm3直接起動かしらんが、gnome-sessionが
sessionマネージャとして走ってgnome-shellが起動される予定。

なお、この時gnome-sessionの
/usr/share/gnome-session/sessions/にて、
gdm-fallback.sessionが選択されるか、
gdm-shell.sessionが選択されるかして、
どちらかのモードが選ばれる。

ここで、defaultファイルである、
/usr/share/gnome-session/sessions/gnome.sessionみると、
/usr/lib/gnome-session/gnome-session-check-accelerated
を動かしてチェックするような事がデフォルトで記載されたりする。

$XDG_CONFIG_HOME/gnome-session/saved-sessionにも
savedセッションとして保存されるので、こちらも見られる。

gnome-session,
gnome-session-save
gnome-session-properties

の３つがgnome-sessionを管轄するコマンド。
他のコマンドなどは、
gnome-session-binパッケージに一通り入ってる。

gnome-session-quitは電源OFFやら、logoffやら担当。

ためしに、
env DISPLAY=:0.0 gnome-session-quit --logout --no-prompt
とかすると、動いているgnome-sessionが停止し、問答無用のログアウトになる。

おっと、なんで
gnome3にて、spice経由であがらんのか良く判ったぜ。
/usr/lib/gnome-session/gnome-session-check-accelerated
が（実際にはgnome-session-check-accelerated-helperが）
/usr/share/gnome-session/hardware-compatibility
を見て（このあたりはどうもハードコーディングされてた)、libGLあたりのチェックぶっこくと、
----ここから----
# Intel 830-865
-Intel\(R\) 8[[:digit:]]{2,2}[^[:digit:]]

# Pre-R300 radeon
-Mesa DRI R[12]00[^[:digit:]]
-Mesa DRI R[12]00$

# Old Mesa software GL renderer
-software rasterizer

# Gallium has softpipe and llvmpipe
-softpipe
-llvmpipe
---ここまで------

こんな事が記載されているのでうまくいかんのじゃぁ。

※たとえ、hardware-compatibility-helper突破してもな。

なんてこった、gnome-session-quitは単にdbusめがけて指令ブチ込むだけでしたー。

なんてこった２

gnome-session-check-acceleratedは、ちょっとwindowのお膳立てをして、
gnome-session-check-accelerated-helperを呼び出すものでした...

gnome-session-3.4.2.1/tools/gnome-session-check-accelerated-helper.c
の以下のコードにニヤリ。
125                                 else /* invalid value */
126                                         ret = 0xDEAD;

DEADって、16進数だったんだー。

で、おもしろいのは、kernelの起動オプションで、gnome.fallback=数字
というのがfallbackで強制アップかどうかを検出する仕組みだった。

とゆーわけで、起動オプションで、gnome.fallback=0とすると
強制的にgnome-shellはgnome-session-check-acceleratedの検査を
スキップして立ち上がるぜ。
--->成功した。
(sid,wheezyともに)

とゆーわけで、llvmだとか、gallium3dだとかお構いなしに立ち上がるぜ。

まあ、ネタとして、virt-viewerでいけるかどうかは試してみようかな。

ただ、debian jessie/sidだといろいろbuggyだけどな。
※gnome-shellのアクティビティ叩いただけで、いろいろ誤動作。

おー、glxgearsで、spiceな環境で、74FPSぐらいは出たぜ。ちょっとガクガクだがな。

とおもって、virt-viewerでやってみたら、笑えるぐらいダメダメ。
glxgearsでは、27.45FPSだった。藁。
おまけにスゲエbuggy。まともにつかえんわー。

さて、gallium3d+llvmpipeでイカシタ状況でwaylandいってみようか。

ごは、llvmpipeのHP(http://www.mesa3d.org/llvmpipe.html)みると、
Support for SSE2 is strongly encouraged. Support for SSSE3 and SSE4.1 will yield the most efficient code. 
らしいので、試しにKVMにて、cpu typeを俺様環境にあわせ、
x86         core2duo  Intel(R) Core(TM)2 Duo CPU     T7700  @ 2.40GHz 
に強制指定してspiceな環境で再度チャレンジしてみよっかなー。
（/proc/cpuinfoによれば、
processor	: 1
vendor_id	: GenuineIntel
cpu family	: 6
model		: 23
model name	: Intel(R) Core(TM)2 Duo CPU     U9400  @ 1.40GHz
stepping	: 6
microcode	: 0x60c
cpu MHz		: 800.000
cache size	: 3072 KB
physical id	: 0
siblings	: 2
core id		: 1
cpu cores	: 2
apicid		: 1
initial apicid	: 1
fpu		: yes
fpu_exception	: yes
cpuid level	: 10
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx lm constant_tsc arch_perfmon pebs bts rep_good nopl aperfmperf pni dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm sse4_1 lahf_lm ida dtherm tpr_shadow vnmi flexpriority
bogomips	: 2793.11
clflush size	: 64
cache_alignment	: 64
address sizes	: 36 bits physical, 48 bits virtual
power management:
なので、最強(藁）スペックだー）

この最高スペックを指定すべく、

  <cpu mode='host-passthrough'/>

つっこんでみた。すんごいことに、Gust上でも、/proc/cpuinfoしたら、
Hostといっしょの能力のCPUが1個みえたぜ。

んー、glxgears は、58〜60FPSだな。

で、試しに、

      <model type='qxl' ram='65536' vram='65536' heads='1'>
        <acceleration accel2d='yes'/> 
      </model>

を付け加えたところ、glxgears 74FPSぐらいは出たぜ。なので、cputypeは
あんまし影響無いなぁ。

ちゅーことで戻す。

まあ、わかったことは、gallium3d+llvmpipeで結構でるっちゅーねん。

で、やってみた。irrlicht1.8をつっこみ、demoの11.PixelPerLightで、
4〜5 FPSは出たぜ。
(Gallium 0.4 on llvmpipe (LLVM 3.2, 128 bits): VMware, Inc.)

まず、
Mesa DRI Mobile Intel® GM45 Express Chipset : Intel Open Source Technology Center
のハードウェアアクセラレーションの元では、FPS:51は安定して軽い。

次に,ベアの

env LIBGL_ALWAYS_SOFTWARE=1 ./11.PerPixelLighting 
Gallium 0.4 on llvmpipe (LLVM 3.2, 128 bits): VMware, Inc.
だと、FPS:12〜15ぐらい。

gallim3d
http://akademy2008.kde.org/conference/slides/zack-akademy2008.pdf

が本家。
(Video : http://stecchino.blip.tv/file/1181861/)

わかりやすい資料は↓
Gallium3D Mesa's New Driver Model
http://www.slideshare.net/olvaffe/gallium3d-mesas-new-driver-model

以前DRIはどうだったかというと...
Data Flow Diagram
http://dri.sourceforge.net/doc/dri_data_flow.html
Control Flow Diagram
http://dri.sourceforge.net/doc/dri_control_flow.html
というまさに、
http://akademy2008.kde.org/conference/slides/zack-akademy2008.pdf
のpp.4のような状況そのもの。

つまりは、DRIがもう大変なことになってたので、
State Trackerと、hwに特化したpipeと、OS/環境依存のpipeにわけちゃえ
という発想で組み直したのがgallium3d。

で、hwに特化したpipeのsoft版rendererは
http://www.mesa3d.org/llvmpipe.html
であり、llvmの機能（動的コンパイラ等込み）を搭載した
めちゃめちゃ速いsoftrendererとなる。

mesa-9.1.6付属の
mesa-9.1.6/src/gallium/docs/以下のレンダリング済み文章
http://people.freedesktop.org/~csimpson/gallium-docs/


なんと、llvmpipeのそこいら中にLLVMの手続きが埋め込まれており、
どうもLLVM Code Representationを使ったコンパイラ（ちゅーか、
オプティマイザ付きアセンブラ）が動く
しくみのようだ。 ニモニックに相当するのはLLVM Intermediate Representation (IR)
つまり、LLVM IRというらしい。
http://www.aosabook.org/en/llvm.html

やるこた
Shaders, point/line/triangle rasterization and vertex processing are implemented with LLVM IR which is translated to x86 or x86-64 machine code.
ということだそうな。まあ、OpenGLって、〜して〜して、んだばレンダリング
してちょ？視点や、カメラの位置はかえるけどな？というような使い方なので、
こういうことできるんですな...たぶん。

そんじゃー、waystonと、waylandいってみようか。

どうでもよいが、linux-image-3.10から、KMS cirrusドライバ
がKVMでも利用できる。

 Step1. libvirtで、cirrus&vncつかえるようにする。
 Step2. debianをKVMでたちあげて、virt-viewerとかでつなぎ、
 Step3. 一旦 sudo service gdm3 stop
 Step4. sudo modprobe cirrus modeset=1
        ※modeset=1がないと絶対にロードされない
 Step5. いきなりコンソール解像度がvirt-viewerで変わる。
 Step6. dmesg | fgrep drmとかすると、drmのcirrusが有効になったことがわかる。

で、xinitとかでいろいろしてみたが、残念ながら、fbdevがKMSなcirrusに
対応していないようで、まったくうごかんぜ。

では、このままwaylandであそぼうとしてみる。

waylandの遊び方：くやしいが、archlinuxがくわしいぜ。
https://wiki.archlinux.org/index.php/Wayland

なぜか、libwayland側は入っているので、
sudo aptitude install weston

するとよい。

ssh して、sudo service gdm3 stop
実行

weston-lanunchではclear_env()されてしまうので、
XDG_RUNTIME_DIRはどうやっても指定できず。なので、
export XDG_RUNTIME_DIR=/tmp
export EGL_DRIVER=/usr/lib/x86_64-linux-gnu/egl/egl_gallium.so
weston --log weston.log 

したが、egl初期化失敗
(実際にはlibgbmで、ドライバ見つからず?
　PCI deviceのリストからドライバ見つからず）

でdrm cirrusではしゅーりょー。

あと良く分からんオプション--use-pixmanというのがあり、
こいつを設定すると、libgdm1が吹っ飛び、westonが死ぬ。

あと、westonのソースみるとわかるが、DISPLAY環境変数あると、
backendとしてxが利用されるらしいぜ。

で、cirrus&vncの結論。

Step 1. Guest OSから、xinitでXあげ。
Step 2. sudo -s -u root -H
Step 3. export XDG_RUNTIME_DIR=/tmp
Step 4. export EGL_DRIVER=/usr/lib/x86_64-linux-gnu/egl/egl_gallium.so
Step 5. 見えているxtermから、westonを実行
　　　　　→glにより全画面奪われ、shellが走る。
Step 6. 別の端末から、KVMへsshする。
Step 7. sudo -s -u root -H
Step 8. export XDG_RUNTIME_DIR=/tmp
Step 9. weston-terminalすると...terminalが現れる。

よかったね！

ここで、cirrus&vncだと画面ぐちゃぐちゃでつかいもんにならんわ。
で、ここで、われらが、qxl+spiceでやってみた。

Step 3. export XDG_RUNTIME_DIR=/tmp
Step 4. export LANG=C
Step 5. gnome-xtermから、westonを実行

weston-terminalとか普通に動く。

（LANG=ja_JP.utf8でやたら横に長い理由はバグのようです：
　https://bugassistant.libreoffice.org/show_bug.cgi?id=63796。
）

chromium-bsuとかいれてみたが、クソ遅くて正直つかいものにならんわー。

llvmpipeがdebianで使える?っていう2012年8月ころの投稿。
http://forums.debian.net/viewtopic.php?f=5&t=82860

lvmpipeはどうも、mesa-9.2シリーズでさらに劇速になるらしい。
http://www.phoronix.com/scan.php?page=article&item=mesa_92dev_llvmpipe&num=1

gnome3がllvmpipeで動いたのはどうも2011/11/03っぽいかな。
http://www.happyassassin.net/2011/11/03/fedora-16-is-gold-but-more-importantly/
http://www.phoronix.com/scan.php?page=news_item&px=MTAxMTI
http://www.phoronix.com/scan.php?page=news_item&px=MTAxMjI

llvmpipe driverは、どうも、2009/9/28のMesa 7.6で搭載されたようだ。
file:///home/nojima/prog/debian/mesa/mesa-9.1.6/docs/relnotes-7.6.html

Gallium3Dは2007/11/13のようだ。
file:///home/nojima/prog/debian/mesa/mesa-9.1.6/docs/index.html

では、ちょっと、gtk-3-examples 3.8.2-3

https://wiki.gnome.org/Wayland/GTK+
みながら、weston-terminalから、
exprot GDK_BACKEND=wayland
aptitude install gtk-3-examples
して、
gtk3-demo
したら、
(gtk3-demo:3370): Gdk-ERROR **: Unsupported GDK backend: wayland
Trace/breakpoint trap

といわれてうごかねー。

----- wheezyでもやってみた---
sudo virt-install --connect=qemu:///system -n debian-wheezy01 --ram 512 --cdrom /home/nojima/prog/net-image/debian-7.1.0-amd64-netinst.iso --disk /var/lib/libvirt/images/debian-wheezy01,bus=virtio,size=10,format=raw,cache=writeback --bridge=br0,model=virtio --graphics spice,port=5901,disable-ticketing --hvm --accelerate --noautoconsole

してみたが、disable-ticketingがうまく指定できずに、認証にTLS使おうとqemuが
エラー吐いてなにもできねー。

 virt-installのソースみるとわかるが、vnc依存が結構凄い。--graphics spiceと
やっても勝手にvirt-viewerを動かそうとするぜ。

というわけで、

sudo virt-install --connect=qemu:///system -n debian-wheezy01 --ram 512 --cdrom /home/nojima/prog/net-image/debian-7.1.0-amd64-netinst.iso --disk /var/lib/libvirt/images/debian-wheezy01,bus=virtio,size=10,format=raw,cache=writeback --bridge=br0,model=virtio --graphics spice,port=5901 -d --hvm --accelerate --noautoconsole

して考えてみた。

すると、

-----デバッグ出力---
...中略...
  <graphics type='spice' port='5901' tlsPort='-1'/>
---中略...
[金, 16  8月 2013 18:56:24 virt-install 15015] ERROR (cli:445) unsupported configuration: Auto allocation of spice TLS port requested but spice TLS is disabled in qemu.conf
[金, 16  8月 2013 18:56:24 virt-install 15015] DEBUG (cli:448) 
Traceback (most recent call last):
  File "/usr/bin/virt-install", line 636, in start_install
    noboot=options.noreboot)
  File "/usr/lib/pymodules/python2.7/virtinst/Guest.py", line 1249, in start_install
    noboot)
  File "/usr/lib/pymodules/python2.7/virtinst/Guest.py", line 1317, in _create_guest
    dom = self.conn.createLinux(start_xml or final_xml, 0)
  File "/usr/lib/python2.7/dist-packages/libvirt.py", line 2892, in createLinux
    if ret is None:raise libvirtError('virDomainCreateLinux() failed', conn=self)
libvirtError: unsupported configuration: Auto allocation of spice TLS port requested but spice TLS is disabled in qemu.conf
[金, 16  8月 2013 18:56:24 virt-install 15015] DEBUG (cli:457) 仮想マシンのインストールが成功したように見えません。
----ここまで

となり、どうも勝手にtlsPort='-1'を突っ込んでしまう挙動だ。

で、なぜかしらんが、VirtualGraphics.pyにて、tlsportは、
値指定してなくても(Value=None)、勝手に-1指定と決め打ちされてしまい、
こちらが原因で勝手にtls指定されてしまう。

See. VirtualGraphics.py
class VirtualGraphics(VirtualDevice.VirtualDevice):

つまりは、virt-installのバグ。実は最近までlibvirtがtlsport attribute
を勝手に指定しまうのを防ぐなどの議論が。
このあたり。
Subject: [libvirt] [PATCHv2] Error out when using SPICE TLS with spice_tls=0
http://osdir.com/ml/libvir-list/2012-02/msg00985.html

正直いってクソ面倒なので、vncでやることに。

 sudo virt-install --connect=qemu:///system -n debian-wheezy01 --ram 512 --cdrom /home/nojima/prog/net-image/debian-7.1.0-amd64-netinst.iso --disk /var/lib/libvirt/images/debian-wheezy01,bus=virtio,size=10,format=raw,cache=writeback --bridge=br0,model=virtio --vnc --hvm --accelerate

いっぱつだった。

-----wayland/westonインストール方法メモ-----------
 sudo qemu-img create -f raw /var/lib/libvirt/images/debian-sid0 7G
 sudo virt-install --connect=qemu:///system -n debian-sid0 --ram 512 --cdrom /home/nojima/prog/net-image/debian-7.1.0-amd64-netinst.iso --disk /var/lib/libvirt/images/debian-sid0,bus=virtio,size=10,format=raw,cache=writeback --bridge=br0,model=virtio --vnc --hvm --accelerate
で、勝手にvirt-viewerが立ち上がるので、

   ----ここから----
 select a language --> Japanese
 場所の選択 ---> 日本
 キーボードの選択 ---> 日本語
ネットワークの設定 --> ネットワークを手動で設定
                     IP:192.168.0.2
                     netmask: 255.255.255.0
                     gateway: 192.168.0.1
                     nameserver: 10.22.80.1 202.234.232.6 221.113.139.250
                     Host名: debian-sid0
                     Domain: local
ユーザとパスワードのセットアップ --> rootのパスワードを入力,
                                  一般ユーザの情報を入力
ディスクのパーティショニング--->ガイド - ディスク全体を使う
                             パーティショニングするディスクの選択：
　　　　　　　　　　　　　　　　　　　仮想ディスク 1 (vda) 
                             すべてのファイルを１つのパーティションに

パッケージマネージャの設定 ---> ミラー：日本 ミラーサイト：ftp.jp.debian.org
                              HTTPプロキシ：なし(空欄)
(こちらでいくつもソフトがネットワーク越しに取ってきてインストールが始まる...)
popularity-contestを設定 ---> いいえ
ソフトウェアの選択 ---> 「SSHサーバー」、「標準システムユーティリティ」のみ選択
　　　　　　　　　　　　　あとは全部解除
マスターブートレコードにgrubインストール --> はい

 (全部カーソルキー選択→Returnで受付)
※オースゲー、virt-installはリブートの場合ちゃんとvirt-viewerを
あげて落としてってやってるぜ。


   ----ここまで----
を選択してインストール。

 rootでログインのち、

/etc/apt/preferences.d/experimental
Package: *
Pin: release experimental
Pin-Priority: 150

/etc/apt/preferences.d/unstable
Package: *
Pin: release unstable
Pin-Priority: 500

/etc/apt/preferences.d/testing
Package: *
Pin: release jessie
Pin-Priority: 150

を作成。

 /etc/apt/sources.listは中身全部を一旦消して
    ----------ここから---------
deb http://ftp.jp.debian.org/debian/ sid main contrib non-free
deb-src http://ftp.jp.debian.org/debian/ sid main contrib non-free
deb http://ftp.jp.debian.org/debian/ experimental main contrib non-free
deb-src http://ftp.jp.debian.org/debian/ experimental main contrib non-free
deb http://ftp.jp.debian.org/debian/ testing main contrib non-free
deb-src http://ftp.jp.debian.org/debian/ testing main contrib non-free
    ----------ここまで---------
に指定。

　/etc/ssh/sshd_configのラストに
  UseDNS no

を挿入

で、aptutude update;aptitude full-upgrade;aptitude cleanを実行。


sudo aptitude install sudo
のあと、
 /etc/sudouers.d/nojimaをchmod 600で作成
-----こっから-------
nojima	ALL=(ALL) NOPASSWD: ALL
-----ここまで-------

sudo aptitude install weston fbset

あとはリブートして様子見
----ここまで-----------------------
※wifi使ってもだいたい丸1時間〜2時間かかる...orz
(そもそも最小限installといえど、200個近いパッケージを遅いI/Oの元で
　インスコするため遅い...)

あと、開発にゃ向いてないので、注意がいる。
開発なんかしたきゃ、
sudo aptitude install build-essential
ぐらいはした方がよい。

また、笑ったのだが、libwaylandを吸い込んでるpackageがあるようだ。
誰だ?

　---------------ここから------------------
apt-cache rdepends libwayland-client0
libwayland-client0
Reverse Depends:
  libwayland-client0:armel
  libwayland-client0:armel
  libwayland-dev
  libwayland-cursor0
  libwayland-client0-dbg
  weston
  libgbm1
  libegl1-mesa-drivers
  libegl1-mesa
  libwayland-client0:armel
  libwayland-client0:armel
  libwayland-dev
  libwayland-cursor0
  libwayland-client0-dbg
  mpv
  libegl1-mesa-drivers
  libegl1-mesa
とのこと。

libwayland-server0
Reverse Depends:
  libwayland-server0:armel
  libwayland-server0:armel
  libwayland-server0-dbg
  libwayland-dev
  weston
  libgbm1
  libegl1-mesa-drivers
  libegl1-mesa
  libwayland-server0:armel
  libwayland-server0:armel
  libwayland-server0-dbg
  libwayland-dev
  libegl1-mesa-drivers
  libegl1-mesa
というわけ。
　---------------ここまで------------------
※multiarch-supportってパッケージ何だ？と思ってdpkg -Lしても
 changelogぐらいしかないぞ。

で、しらべると。
westonはexperimentalだけ。

http://packages.debian.org/search?keywords=weston&searchon=names&suite=all&section=all

藁。

-----------------
weston-1.1.1（今は、debianはtesting/sidはweston-1.3.0）

westonのmain関数は、src/compositor.cにあるっぽい。

src/compositor.cでさがすと、
なんと、wl_display_createとかは、wayland側にあるぜ。
--->つまりは、サーバーの抽象部分のコードはlibwaylandのなか。

で、weston-1.1.1/compositor-XXXX.cにてハードウェア初期化を行う。
ハード初期化エントリ部分はbackend_init()が担当。
->compositor-rpi.cってRasspberry Piのcompositorだった....)
->compositor-headlessってよくわからんが、画面なしモードのようだ。
-> compositor-fbというのがlinux frame buffer経由でハンドリング
　　---> udlfbというのはDisplayLinkとよばれ、USBで画面だせるやつ。
        See. https://wiki.archlinux.org/index.php/DisplayLink
   ---> cirrusならいけるぜ。
　      今度やってみよう。
　 ---> vesafbではどうかなー。
       よーわからんが、uvesafbというのが該当か?
       
modprobe uvesafbとかしてみたところ、
/sbin/v86dとかがないとかでエラーにあった。
なんじゃこりゃ？
--> aptitude show v86dとかすると、
------中略-----
daemon to run x86 code in an emulated environment
 v86d provides a backend for kernel drivers that need to execute x86 BIOS code. The code is
 executed in a controlled environment and the results are passed back to the kernel via the
 netlink interface. 
 
 v86d is needed by the uvesafb kernel module.
ホームページ: http://dev.gentoo.org/~spock/projects/uvesafb/
-----ここまで------
ということらしい。

で、qxlの元で
aptitude install v86d
とかして、ブートプロンプトで、
video=uvesafb:1024x768-32@60とかやってみたが、
uvesafbがvesa bios見つからんのでコケてNGだった。

あー、普通にmodprobe cirrusfbしただけだと、
[01:26:58.108] Calculating pixman format from:
                - type: 0 (aux: 0)
                - visual: 3
                - bpp: 8 (grayscale: 0)
                - red: offset: 0, length: 8, MSB: 0
                - green: offset: 0, length: 8, MSB: 0
                - blue: offset: 0, length: 8, MSB: 0
                - transp: offset: 0, length: 0, MSB: 0
となり、westonが対応できるフォーマットである、
TRUECOLORではない為、起動できず。
fbset -fb /dev/fb0 -g 1024 768 1024 768 24
(fbsetは aptitude install fbset)
とかして強制的にTRUECOLORにしてみたが、westonが起動して、
ioctl(fd, FBIOGET_VSCREENINFO)の返り値が、
なぜか元のまま。

---> virt-viewer にてvt 8に切り替えてから、別コンソールで、
     fbset -fb /dev/fb0 -g 1024 768 1024 768 24
　　　とかしたら、今度はちゃんとbpp:24 visual2 で読み込んでくれた。
　　　で、
      env LANG=C weston --backend=fbdev-backend.so
      で起動に成功！Yeah!

env LANG=C weston --modules=tablet-shell.so --backend=fbdev-backend.so
したら、tabletモードになった。が、weston-terminal
しても何も起動せず。キーバインディングもよくわからん。

---- KVMでのうごかしかた----
virt-viewer で、Ctl-ALT-F1
rootでログイン

service gdm3 stop
fbset -g 1024 768 1024 768 24
export XDG_RUNTIME_DIR=/tmp
env LANG=C weston --backend=fbdev-backend.so

あと、CTRL+ALT+BACKSPACEで終了。



root@debian-sid0:/home/nojima# fbset -i

mode "640x480-60"
    # D: 25.175 MHz, H: 31.469 kHz, V: 59.940 Hz
    geometry 640 480 1024 768 24
    timings 39722 48 16 33 10 96 2
    accel true
    rgba 8/16,8/8,8/0,0/0
endmode

Frame buffer device information:
    Name        : CL Picasso4
    Address     : 0xfc000000
    Size        : 4194304
    Type        : PACKED PIXELS
    Visual      : TRUECOLOR
    XPanStep    : 1
    YPanStep    : 1
    YWrapStep   : 0
    LineLength  : 3072
    Accelerator : Trident BladeXP


compositor-fbdev.cのソースから、
fbdev_frame_buffer_open()-->fbdev_query_screen_info()-->exit()
のBadEndコースでした。


ところで、pixmanって、drmでつかえるんだがこれなに。
A Software-Based Pixman Renderer For Wayland's Weston
http://www.phoronix.com/scan.php?page=news_item&px=MTI2Nzg

なんかしらんが、MIT-shmでやるそうな。

本家↓
pixman
http://pixman.org/

しらんかった。こんなのがあるのかー。compositor-x11.cで
しらべても--use-pixman=1がある。おおー。

Xのうえで、
weston --use-pixman=1
としたら動いた。で、
Using pixman renderer
とかでてるんだな。これが。

ちょっと早くなった気がする。うそかもしらんが。
pixmanはcairographics.orgの生産物
-> http://cairographics.org/




で、さらにcodesearch.debian.netとかで探すと、wayland用のコードが
なぜかmesaのegl/以下に...

なぜか、libwaylandはwheezyにもある。ver 0.85だけどな。

debianでは、westonコンパイルののちインストールは、
debian/install
で指定されているバイナリのみ。

なぜだろう？

実際、
aptitude build-dep weston
aptitude install jpeg-dev
で、

dpkg-buildpackageでbuildして
$(src)/client/
以下にテストクライアントである、
flower,
gears
....
等が入ってる。

cirrus+fb経由だと、gearsは8FPSだってさ。
flower ---> 縁なし非四角のウィンドウを出すデモ
calibrator--->タッチパネル用の調整
clickdot  ---> 線引くデモ
cliptest
dnd --> drag and drop test
editor ---> form入れのテスト。ソフトキーボードでてくる。
eventdemo-->よくわからん
image---> image image-fileとやると表示される。
smoke ---> 煙の描画テスト

まあ、こんなもんか。

-----------xもしゃべらせる---------
sudo -s -u root -H
update-rc.d gdm3 disable
cat .conf/weston.ini
-----ここから----
[core]
modules=xwayland.so,desktop-shell.so
-----ここまで----
export XDG_RUNTIME_DIR=/tmp
modprobe cirrusfb
fbset -g 1024 768 1024 768 24
cat /etc/X11/xorg.conf
-----ここから---
Section "Device"
	Identifier "Device"
	Driver "fbdev"
EndSection
-----ここまで---
env LANG=C weston --log=weston.log --backend=fbdev-backend.so

でもね、desktop-shellにweston-terminalはでないわ、
Xはあがってないわでうまく行っている様にはみえん。

weston-terminalから、
export DISPLAY=:0.0
xlogo
とかやってみたが、
Can't open display
といわれてしゅーりょー。

いちおう、単体でxinitしてみたが、無問題で起動できる。

-----ksm---

GBMとは、Generic Buffer Managementというらしい。
KSMチュートリ：
See. 
libgbmをつかうわけだ。
http://virtuousgeek.org/blog/index.php/jbarnes/2011/10/31/writing_stanalone_programs_with_egl_and_

mesaの
src/gbm/backends/dri/gbm_dri.cにて、GBMの組み込み済み
バックエンドのdriソースが入ってる。一方で、
GBM_BACKEND=gbm_dri.soか、
GBM_BACKEND=gbm_gallium_drm.so
のどちらを環境変数に指定すると使える。
--->と思ったらウソでしたー。GBM_BACKEND指定してても、
　　　両方順番にロードされますー。
　　
ブートときにKMS有効にするなら、KVMだと、
cirrus.modeset=1
を起動オプションに突っ込むと有効になる。


GBM_BACKEND=gbm_dri.soにして、gdbでおっかけてみた。

_gbm_create_device()($(MESA_SRC)/src/gbm/main/backend.c)
---> backend->create_device(fd)
---> dri_device_create ($(MESA_SRC)/src/gbm/backends/dri/gbm_dri.c)
　　なお、dri->base.driver_name=driだそうな。
　　
で、結局gbm_gallium_dri.soが吸い込まれ、
 pip_loader_drm_probe_fd(pipe_loader_drm.c)にてgallium3d用
デバイスドライバが吸い込まれるはずであるが、ここで、
pciデバイスのIDから検索しても、
$(MESA_SRC)/include/pci_ids/pci_id_driver_map.h
の
 static const struct {
 61    int vendor_id;
 62    const char *driver;
 63    const int *chip_ids;
 64    int num_chips_ids;
 65 } driver_map[] = {
 66    { 0x8086, "i915", i915_chip_ids, ARRAY_SIZE(i915_chip_ids) },
 67    { 0x8086, "i965", i965_chip_ids, ARRAY_SIZE(i965_chip_ids) },
 68 #ifndef DRIVER_MAP_GALLIUM_ONLY
 69    { 0x1002, "radeon", r100_chip_ids, ARRAY_SIZE(r100_chip_ids) },
 70    { 0x1002, "r200", r200_chip_ids, ARRAY_SIZE(r200_chip_ids) },
 71 #endif
 72    { 0x1002, "r300", r300_chip_ids, ARRAY_SIZE(r300_chip_ids) },
 73    { 0x1002, "r600", r600_chip_ids, ARRAY_SIZE(r600_chip_ids) },
 74    { 0x1002, "radeonsi", radeonsi_chip_ids, ARRAY_SIZE(radeonsi_chip_ids) },
 75    { 0x10de, "nouveau", NULL, -1 },
 76    { 0x15ad, "vmwgfx", vmwgfx_chip_ids, ARRAY_SIZE(vmwgfx_chip_ids) },
 77    { 0x0000, NULL, NULL, 0 },
 78 };
に、cirrusは存在しないので、ロードできず。
で、gallium_screen_create(gbm.c)は失敗に終わる。
---> gbm_gallium_drm_device_create(gbm_drm.c)は失敗におわる。

つまりは、なにしてもkms/cirrus.koの元ではNG。

------- xwayland試し-----

env LANG=C weston --log=weston.log --modules=xwayland.so,desktop-shell.so --backend=fbdev-backend.so

で起動かけてみたら、ちゃんと、

[02:50:24.107] xserver listening on display :0

とかでるんだけど、weston-terminal上で、xlogoとか動かすと
Cant open display :0
とか言われてNG。なんでじゃ？

うおー、xwayland/launcher.cでexecしてるぜ。

[02:56:15.880] lock surface gone
[02:56:38.678] forked X server, pid 2610
[02:56:38.747] libwayland: disconnect from client 0x1af4500
[02:56:38.747] xserver crashing too fast: 256

とかで死にまくってるぜ。

で、見ると、
/usr/bin/Xorg :0 -wayland -rootless -retro -nolisten all -terminate
で実行しているとおもわれ。エラーメッセージから、-waylandが問題。
-waylandをサポートできてるxorgバイナリでないと、xwayland.soはXを
launch出来ない模様。

/root/.config/westion.iniには、以下の設定を入れてみる。
-----ここから-----------
[shell]
background-image=/usr/share/wallpapers/joy/contents/images/1024x768.png
background-type=tile
locking=true
animation=zoom
num-workspaces=6
binding-modifier=ctrl


[launcher]
icon=/usr/share/weston/terminal.png
path=/usr/bin/weston-terminal
----ここまで------------
とりあえず、壁紙はJoyになるし、zoomのアニメーションしてちょっとだけクール。

知らんかったが、VTはtty0で起動。画面切り替えたかったら、Ctl+ALT+F2とか。
fbdevはpixman経由のレンダラ。

なんかしらんが、compositorは直接udevとお話しするらしい。
デバイスの追加等は直接udevから得る仕組み。compositorのevent handlerに
直接登録されるようだ。

画面ショットもshellの役目らしい。
（See. screenshooter-protocol.c)
スクリーンセーバーもshellの役目。
See. src/desktop-shell-protocol.c
一応shellの動きはprotocol経由で変更かのうらしい。
workspaceもshellの役目。
See. workspaces-protocol.c

なんてこった、rdp用途のbackendが無い...
※configure.ac確認するとデフォルトでenable_rdp_compositor=noなので、
 rulesのconfigureにては、--enable-rdp-compositorする必要あり。

見ると、westonはshellを2系統内臓している構造。
なお、dynamic linkなモジュールで持つ部分と、
weston-desktop-shell/weston-tablet-shell
として実行形式で持つ部分に分かれる模様。

westonの心臓部はeventハンドラ。

shellのお仕事は、shell,screensaver,input(softkey board?),panelI/F,
workspace manager等。

内部ではsignal飛ばしまくってイベントドリブンする。
--->今時のアーキテクチャ

westonのmainは、compositor.cとなる。

wl_display()でいろいろ登録。
  ---> 環境変数 WAYLAND_DEBUG=serverとかするとサーバー側のデバッグコードが走る。
     んでもって、epollがイベントドリブンの心臓部だったわ。
      で、良く判らんが、wl_display_add_globalとかしてるし、
　　　中では、どこかに何かを飛ばしてる...
　　　　※closureなので、適当に関数作って呼び出しまくるらしい。

  ---> --backend=のxxx-backend.so中のbackend_init()がバックエンド
　　　　の初期化エントリー部分。
　　　  keyboardはxkb_context_new(0)で作ってるぜ。

  ---> screen_shooterは出力先をバッファにしてrepaintする作り。
      (see. screenshooter.c screenshooter_shoot())
      うは、しかも手でコピーだ...

  ----> イベントは各種キューにぶち込んでdispatchというのが基本構造。

  ALTか、CTL+Sでshoot?(weston-screenshooterがランチする。このアプリの名前はハードコーディングされてる。)
  ALTか、CTL+Rでレコーダ？(filename=capure.wcapだそうだ)
  レコーダ形式はWCAP形式とのこと。

　text_backend()とはなんだ？text_cursor_position_notifier_create()とか
　あるらしい。---> input-methodのことだった。weston.iniで変えられる。
　デフォルトではweston-keyboardだ。

  おお、すっげー、udev_new()とかしてるぜ。ハードこいつでハンドル
　するつんもりらしい。

  ハードの何かをseatと呼ぶ。
  画面切りもやるらしい（dpmsとお話してるぜ）
  weston本体はCTLもしくはALT+F1-9が仮想画面切り替えに使えるらしい...

  Rキーにdebugコード仕込んでる。なんだろう？
　fbdevは基本的にpixman使う。
　（weston-1.1.1/src/pixman-renderer.cがラッパー）

  composter-fbdev.cのfbdev_query_screen_info()は、fbdevから、
　情報を得る。この時実サイズと、仮想サイズの2通りを取ってくるようだ。


 うは、開けた/dev/fb0とかをmmapしてフレームバッファ直接共有かー。

 画面回転もサポートだー。
 pixmanは座標変換（ローテーションとか）もお手の物らしい。


weston-1.1.1/src/evdev.cのevdev_led_xxxxってキーボードのLEDの事。
/dev/fb0とかにメッセージとして書き込むと、LED制御が可能。

udevにカテゴリinputでnotifyかかると、epollとかでひっぱってくる。
-->基本的にudevは入力デバイスハンドリングに使われるようだ。
--> 個別のハードウェアI/Fのことをseatというらしい。

weston-1.1.1/src/udev-seat.cのdevice_add()では、
udev_device_get_property_value()のWL_CALIBRATION項目に
一定のキャリブレーション用のデータが突っ込まれるお約束になっているらしい。

weston-1.1.1/src/compositor.cのデフォルトでは、
modules=desktop-shell.so
option_modules=NULL
がデフォルト。

モジュールのエントリポイントは、module_init()という関数。
desktop-shell.so--->shell.c
tablet-shell.so --> tablet-shell.c

窓アニメーションしたり、スクリーンセーバーはshellの役目。

animationはzoom/fadeしかない。その他指定するとanimationなし。

0番目のワークスペースが必ず最初に有功になる。
ワークスペースも移動するとアニメーションするような事が書いてある気がする。

で、weston-1.1.1/src/compositor.cはwl_display_run()でくるくる回る。

weston-1.1.1/src/shell.cのshell_add_bindings()に
desktop-shell.so固有のキーバインドがハードコーディングされてるぜ。
CTRL/ALT+BACKSPACEで終了らしい。
 ---> wl_display_terminate()で無事終了できるようにする。
ALT+縦スベリで、透明度のコントロール?
MODIFIER_SUPERって何キー？
(CTRL/ALT/SHIFTは普通にある)
-->http://ja.wikipedia.org/wiki/%E4%BF%AE%E9%A3%BE%E3%82%AD%E3%83%BC
   用はwindowsキーとからしい。
SUPERキー(windowsキー)押したら、
[10:40:44.457] pixman renderer does not support zoom
[10:40:44.457] pixman renderer does not support zoom
[10:40:44.486] pixman renderer does not support zoom
[10:40:44.487] pixman renderer does not support zoom
[10:40:44.487] pixman renderer does not support zoom
[10:40:44.519] pixman renderer does not support zoom
[10:40:44.520] pixman renderer does not support zoom
とか言われてハング。


WAYLAND_DEBUG=server
とかすると、ログが出るわ出るわ...

Date: 2013-08-28 JST
[17:09:12.283] weston 1.1.1
               http://wayland.freedesktop.org/
               Bug reports to: https://bugs.freedesktop.org/enter_bug.cgi?product=Wayland&component=weston&version=1.1.1
               Build:  
[17:09:12.284] OS: Linux, 3.10-2-amd64, #1 SMP Debian 3.10.7-1 (2013-08-17), x86_64
[17:09:12.284] warning: XDG_RUNTIME_DIR "/tmp" is not configured
correctly.  Unix access mode must be 0700 but is 777,
and XDG_RUNTIME_DIR must be owned by the user, but is
owned by UID 0.
Refer to your distribution on how to get it, or
http://www.freedesktop.org/wiki/Specifications/basedir-spec
on how to implement it.
couldn't open /root/.config/weston.ini
[17:09:12.419] Loading module '/usr/lib/x86_64-linux-gnu/weston/fbdev-backend.so'
[17:09:12.452] initializing fbdev backend
couldn't open /root/.config/weston.ini
couldn't open /root/.config/weston.ini
[17:09:12.471] compositor: using new vt /dev/tty7
[17:09:12.493] Creating fbdev output.
[17:09:12.493] Opening fbdev frame buffer.

superキーが判ったので、tablet-shell.soしたら...端末iconは出るようになったが、
それ以上がない

 -----ここから----
/root/.config/weston.ini
[core]
modules=tablet-shell.so

[shell]
background-image=/usr/share/wallpapers/joy/contents/images/1024x768.png
background-type=tile
locking=true
animation=zoom
num-workspaces=6
binding-modifier=ctrl


[launcher]
icon=/usr/share/weston/terminal.png
path=/usr/bin/weston-terminal
----ここまで-------
また、
 weston --backend=fbdev-backend.so
しないと起動しない。
（[core]セクションに登録してみたが、ダメ
  modules=fbdev-backend.so,tablet-shell.soとかね）

※最初/root/.config
あと、エラーメッセージが絶望的...

[10:11:08.538] libwayland: using socket /tmp/wayland-0
[10:11:12.514] libwayland: disconnect from client 0xa91440
[10:11:12.515] input_method died, respawning...
[10:11:12.515] launching '/usr/lib/x86_64-linux-gnu/weston-keyboard'
couldn't load background image: (null)
[10:11:12.747] libwayland: disconnect from client 0xa91440
[10:11:12.747] input_method died, respawning...
[10:11:12.747] launching '/usr/lib/x86_64-linux-gnu/weston-keyboard'
[10:11:12.954] libwayland: disconnect from client 0xa91440
[10:11:12.955] input_method died, respawning...
[10:11:12.955] launching '/usr/lib/x86_64-linux-gnu/weston-keyboard'
[10:11:13.133] libwayland: disconnect from client 0xa91440
[10:11:13.134] input_method died, respawning...
[10:11:13.134] launching '/usr/lib/x86_64-linux-gnu/weston-keyboard'
[10:11:13.315] libwayland: disconnect from client 0xa91440
[10:11:13.315] input_method died, respawning...
[10:11:13.315] launching '/usr/lib/x86_64-linux-gnu/weston-keyboard'
[10:11:13.499] libwayland: disconnect from client 0xa91440
[10:11:13.500] input_method died, giving up.

couldn't load background image: (null)
couldn't load lockscreen icon: (null)
couldn't load background image: (null)
couldn't load background image: (null)
とか言われる。

キーボードが死滅しているので、CTL+BACKSPACEもキカネー/SUPERキー何それ

desktop-shell.soだと、
4122         weston_compositor_add_key_binding(ec, KEY_PAGEUP, mod,
4123                                           zoom_key_binding, NULL);
4124         weston_compositor_add_key_binding(ec, KEY_PAGEDOWN, mod,
4125                                           zoom_key_binding, NULL);
4126         weston_compositor_add_button_binding(ec, BTN_LEFT, mod, move_bindin     g,
4127                                              shell);
4128         weston_compositor_add_button_binding(ec, BTN_MIDDLE, mod,
4129                                              resize_binding, shell);
4130         weston_compositor_add_button_binding(ec, BTN_RIGHT, mod,
4131                                              rotate_binding, NULL);
4132         weston_compositor_add_key_binding(ec, KEY_TAB, mod, switcher_bindin     g,
4133                                           shell);
4134         weston_compositor_add_key_binding(ec, KEY_F9, mod, backlight_bindin     g,
4135                                           ec);
4136         weston_compositor_add_key_binding(ec, KEY_BRIGHTNESSDOWN, 0,
4137                                           backlight_binding, ec);
4138         weston_compositor_add_key_binding(ec, KEY_F10, mod, backlight_bindi     ng,
4139                                           ec);
4140         weston_compositor_add_key_binding(ec, KEY_BRIGHTNESSUP, 0,
4141                                           backlight_binding, ec);
4142         weston_compositor_add_key_binding(ec, KEY_K, mod,
4143                                           force_kill_binding, shell);
4144         weston_compositor_add_key_binding(ec, KEY_UP, mod,
4145                                           workspace_up_binding, shell);
4146         weston_compositor_add_key_binding(ec, KEY_DOWN, mod,
4147                                           workspace_down_binding, shell);
4148         weston_compositor_add_key_binding(ec, KEY_UP, mod | MODIFIER_SHIFT,
4149                                           workspace_move_surface_up_binding     ,
4150                                           shell);
4151         weston_compositor_add_key_binding(ec, KEY_DOWN, mod | MODIFIER_SHIF     T,
4152                                           workspace_move_surface_down_bindi     ng,
4153                                           shell);
のはずが、まったくキーが入らないぜ。なんでだ？

weston基本構造

weston-> 画面初期化->shell -> weston-xxxshell起動 
-->あとはevent driven.

eventはepol+signalの組み合わせでハンドリング。

WAYLAND_DISPLAY=って、ディスプレイ名というのか？
どうも、フォーマットはwayland-0という感じの名前。
PF_LOCALでこの名前でsoket openするので、UNIXドメインソケット。

pixmanはドキュメントが存在しないらしい。
--->ソース嫁ってさ。
で、apt-get source libpixmanして中身見たら...
各cpu用に最適化された命令を駆使した描画エンジンだった...
cpu detectorとかあるある...
pixman-x86.cなんて中身ほとんどASM命令の塊...
API一覧はpixman.hを参照。

pixmanがやってそうな事は基本的な（といっても今時の操作が多い）2D操作
を全部CPU最適で回そうということらしい。


westonでは、Rキー押下にpixman使用時にデバッグスクリーンが出る
仕組みらしい...(が、shellか、xkbに奪われてしまう感じがするがどうなんだろう？
）--->R押しても何も起きんかった...

linux fbは、
 open(fb,O_RDWR|O_CLOEXEC)
 ioctl(fd,FBIOGET_XXXXXX,*ptr)--->fb情報引き抜き
 output=mmap(...)

で、
pixman-src/pixman/pixman-bits-image.c
にて、

 PIXMAN_EXPORT pixman_image_t *
1787 pixman_image_create_bits (pixman_format_code_t format,
1788                           int                  width,
1789                           int                  height,
1790                           uint32_t *           bits,
1791                           int                  rowstride_bytes)

して*bitsにframebufferのI/Oバッファのポインタをわたすらしい...

pixman_image_set_transform()
pixman_renderer_output_create()

westonはこのあと、wl_event_loop_add_timer()にぶちこんで、
イベントループする。


weston-src/src/comositor.cが描画ハンドラ。

weston-src/src/compositor-fbdev.cにて、
fbdev_output_repaint()内部で
pixman_image_compsite32()

weston再構築のばあい、libwaylandは1.1.0-2を利用しないと
いろいろ変わりすぎて構築不能。

sudo aptitude libwayland-hoge/testing
とかする

で、cirrus KMS にてweston drm-backend,use-pixmanでぶっとぶ理由は、

(gdb) bt
#0  drm_fb_create_dumb (ec=0x62aab0, width=1280, height=1024) at compositor-drm.c:262
#1  0x00007ffff43dce6e in drm_output_init_pixman (output=0x62e430, c=0x62aab0)
    at compositor-drm.c:1453
#2  0x00007ffff43dd96b in create_output_for_connector (ec=0x62aab0, 
    resources=0x62c720, connector=0x62cb00, x=0, y=0, drm_device=0x62cbe0)
    at compositor-drm.c:1642
#3  0x00007ffff43de386 in create_outputs (ec=0x62aab0, option_connector=0, 
    drm_device=0x62cbe0) at compositor-drm.c:1821
#4  0x00007ffff43df447 in drm_compositor_create (display=0x629970, connector=0, 
    seat=0x7ffff43e5e70 <default_seat> "seat0", tty=0, pixman=1, argc=0x7fffffffe49c, 
    argv=0x7fffffffe738, config_file=0x629cb0 "/root/.config/weston.ini")
    at compositor-drm.c:2273
#5  0x00007ffff43e00a5 in backend_init (display=0x629970, argc=0x7fffffffe49c, 
    argv=0x7fffffffe738, config_file=0x629cb0 "/root/.config/weston.ini")
    at compositor-drm.c:2521
#6  0x000000000040fd6e in main (argc=1, argv=0x7fffffffe738) at compositor.c:3607

259		ret = drmModeAddFB(ec->drm.fd, width, height, 24, 32,
(gdb) 
261		if (ret)
(gdb) 
262			goto err_bo;

ということで、drmModeAddFBが失敗に終わって吹っ飛ぶ。

参考：KMSの遊び方
http://virtuousgeek.org/blog/index.php/jbarnes/2011/10/31/writing_stanalone_programs_with_egl_and_
が超詳しい。(eglの例だけどな）

上のdrmModeAddFBは、
In this example, we’re assuming a 24 bit depth buffer with 32 bits per pixel. 
という意味じゃ。

で、わけわかめなのだが、24bit depth 32bits per pixは、
linux-3.11~rc4/drivers/gpu/drm/cirrus/cirrus_mode.c
だとサポートされてるぜ...orz

libgbm1って、Mesa3dの成果物だったのね。drmも扱えるframe buffer用
ライブラリらしい...

westonのcompositor-fbdev.cでは、端末切り替えたりいろいろする。
この時のお約束の処理は、
man console_ioctl
--->まあ、無いよりはマシ程度の内容だけどな。

で引ける内容が利用される。
（例：ioctl(fd,VT_GETSTATE,...)とかね）

vtまわりは、chvtとか、openvtとかのソースが参考になるはず。
（パッケージはkbdパッケージ)

----------------取り急ぎ vt切り替えて、そこからキーボード奪うソース-----------
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/vt.h>
#include <linux/kd.h>
#include <termios.h>
#include <unistd.h>
#include <string.h>

int main (int argc,char **argv)
{
	int tty0_fd,new_vt;
	int new_tty_fd,kb_mode;
	struct vt_stat vts;
	char fname[16];
	struct termios tty_attr;
	char tty_buf[10];
	int n_char;
	tty0_fd=open("/dev/tty0",O_WRONLY | O_CLOEXEC);
	if (tty0_fd < 0) {
		perror("uh? cant open /dev/tty0,abort");
		exit(1);
	}
	if ( ioctl(tty0_fd,VT_OPENQRY,&new_vt) <0 ) {
		perror("uh? cant query new vc,abort");
		exit(1);
	}
	if (new_vt <0) {
		fprintf(stderr,"no more new vc,abort");
		exit(1);
	}	
	close(tty0_fd);
	snprintf(fname,sizeof(fname),"/dev/tty%d",new_vt);
	new_tty_fd=open(fname, O_RDWR | O_NOCTTY | O_CLOEXEC);
	if (new_tty_fd <0) {
		perror("uh? cant open new vc ,abort");
		exit(1);
	}
	if (ioctl(new_tty_fd, VT_GETSTATE, &vts) ==0) {
		if (ioctl(new_tty_fd, VT_ACTIVATE, new_vt) <0) {
			perror("uh? cant active new vc ,abort");
			exit(1);
		}
		if (ioctl(new_tty_fd, VT_WAITACTIVE, new_vt) <0) {
			perror("uh? cant wait for activation of new vc ,abort");
			exit(1);
		}
	}
	printf("Now activate %s ...\n",fname);
	if (tcgetattr(new_tty_fd,&tty_attr) < 0 ) {
		perror("uh? cant get attribute of tty,abort");
		exit(1);
	}
	cfmakeraw(&tty_attr);
	tty_attr.c_oflag |= OPOST | OCRNL;
	if (tcsetattr(new_tty_fd,TCSANOW, &tty_attr) < 0 ) {
		perror("uh? cant set attribute of tty,abort");
		exit(1);
	}
	if (ioctl(new_tty_fd, KDSKBMODE,K_OFF)) {
		if (ioctl(new_tty_fd, KDSKBMODE, K_RAW)) {
			perror("uh? KBD is not set K_RAW,abort");
			exit(1);
		}
	}
	if (ioctl(new_tty_fd, KDSKBMODE,KD_GRAPHICS)) {
		perror("uh? KBD is not set KD_GRAPHICS,abort");
		exit(1);
	}
	while(1) {
		memset(&tty_buf[0],0,sizeof(tty_buf));
		n_char=read(new_tty_fd,&tty_buf[0], sizeof(tty_buf)-1);
		if (n_char <0) {
			perror("uh? failure to read from tty,abort");
			exit(1);
		} else if  (n_char == 0) {
			sleep(1); /* avoid busy loop */
		}
		printf("key=%s\n",&tty_buf[0]);
	}	
	close(new_tty_fd);	
	exit(0);
}
----------------取り急ぎ vt切り替えて、そこからキーボード奪うソースここまで-----------

次の内容として、

  - fb
  - pixman
  - waylandとwestonとアプリの間の通信
  - gnomeのwaylandの連携方法
  - xwaylandとの連携
  - libmesaのOpenGL系の実装
  - linux DRM/KMS絡み

などに発展させればいいかな...

うおっと、現在、westonはtesting/sidには入ってる。（waylandはもともと入ってる...)
1.3.0-が最新判だ。upstreamも1.3.0だった。

今のsidの場合、

 /etc/groupのweston-launchグループに自分を付け加え、
ログアウトー＞ログインして、
export XDG_RUNTIME_DIR=/tmp
weston-lauch -- --backend=fbdev-backend.so --log=weston.log -v
とかして立ち上げればOKなのだが、落ちる。
---> XDG_RUNTIME_DIRって最新のsidだとログイン後、勝手に定められる。
     XDG_RUNTIME_DIR=/run/user/1000
    こんな感じ。codesearch.debian.netでXDG_RUNTIME_DIRとかすると、
　　systemdが定めてるっぽい。
　　仕組み的には、
     systemd-logindがもろもろ準備してXDG_RUNTIME_DIRを作る能力あり
　　 systemdが用意する、pam_systemdがsystemd-logindと通信して、
　　このあたりの準備をする。ちなみに、pam_systemdは/etc/pam.d/common-session
    から呼び出される。See. man pam_systemdに記載あり。
　　　最小限インストールだと、systemdが入ってなくてこちらが
　　動かんので注意。


--> westonがweston-launchと通信するのでweston-launchは必須。

debian-sidでcirrusfbでwestonが動かんので、仕方ないので、以下の方法
でデバッグ中。

sudo -s -u root -H
cd /usr/bin/
mv weston weston.bin
cat > weston
#!/bin/sh
PATH=/bin:/usr/bin
gdbserver localhost:8000 /usr/bin/weston.bin $@
<Ctrl-D>
chmod 755 weston

で、virt-viewerから、
weston-launch -- --backend=fbdev-backend.so --log=weston.log
とすると、待機状態になる。

どっかの窓から、
ssh debian-sid0
gdb /usr/bin/weston.bin
(gdb) target remote localhost:8000
(gdb) いきなりデバッグ可能。

で、しらべると、


WESTON_LAUNCHER_SOCKでこけてるらしい。

2度目のデバッグは、
再度virt-viewerで、
weston-launch -- --backend=fbdev-backend.so --log=weston.log
して止まったら、
gdbのセッション上で、
target remote localhost:8000
とかすればOK。

参考になるかはしらんが、
 weston:
  compositor.c:main 
  compositor.c: backend_init
3514		ec = backend_init(display, &argc, argv, config);

     compositor-fbdev.c: backend_init
      
902 compositor-fbdev.c: 

launcher-util.c:340
334	struct weston_launcher *
335	weston_launcher_connect(struct weston_compositor *compositor, int tty)

compositor.c:2955 
weston_environment_get_fd('WESTON_LAUNCHER_SOCK')

うあああ、WESTON_LAUNCHER_SOCK未定義だー。
ついでに、geteuid()!=0だぁぁ。(==1000だった...)

weston-launch.c:launch_compositor()
にて、root->ユーザ
へわざわざ権限落としてる。
で、gdbで
(gdb)  print environ[0]
〜
(gdb)  print environ[18]
=NULL

までやってみたところ、weston-launcherで引き継がれるはずの
WESTON_LAUNCHER_SOCKと、
WESTON_TTY_FD
の両方が未設定だー。

まあ、これが原因かな...
        child_argv[0] = wl->pw->pw_shell;
        child_argv[1] = "-l";
        child_argv[2] = "-c";
        child_argv[3] = BINDIR "/weston \"$@\"";
        child_argv[4] = "weston";
        for (i = 0; i < argc; ++i)
                child_argv[5 + i] = argv[i];
        child_argv[5 + i] = NULL;

        execv(child_argv[0], child_argv);

つまり、bash経由なので、環境変数が全部初期化されちゃう...
ああああ、なんてこった。--->嘘。envとったら、
WESTON_TTY_FD=0
WESTON_LAUNCHER_SOCK=4
って指定されていたぜ。

あれ？
fbdev_compositor_create中で、
p *environとかすると、
WESTON_TTY_FD=0
が指定されてた...

あれ？ 
compositor-fbdev.c:898でenvironしらべたら、
WESTON_TTY_FD=0
が消えていた...どこで消去されるんだ？

最初の
compositor-fbdev.c:884の
 weston_launcher_connect()
の呼び出しで消えちゃってた。

こいつの原因は、weston_environment_get_fd()が原因。
あああ、
WL_EXPORT int
weston_environment_get_fd(const char *env)
{
        char *e, *end;
        int fd, flags;

        e = getenv(env);
        if (!e)
                return -1;
        fd = strtol(e, &end, 0);
        if (*end != '\0')
                return -1;

        flags = fcntl(fd, F_GETFD);
        if (flags == -1)
                return -1;

        fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
        unsetenv(env);

        return fd;
}
ということで、unsetenv(env)されてるぜ。

compositor-fbdev.c:897〜907までがなんかおかしい。
debianのパッチが悪さしてる?
--->debian/patch以下にパッチはなかった。
--->？するとupstreamか？

ぐあああ、めちゃくちゃ手がかかるぜばろー。

ああああ、
http://cgit.freedesktop.org/wayland/weston/commit/src/compositor-fbdev.c?id=4f49917ec5a3e212d85b15c96a580116c3ef5a15
みると、2013/2月ころのcommitなら問題ないぜ。問題はこの後のcommitだ...
weston_launcher_connect
が挿入された時点で多分おかしくなった。

ってbugfixしてやがる。

2013-10-15
http://cgit.freedesktop.org/wayland/weston/commit/src/compositor-fbdev.c?id=1641d14b824df487bba23597aa128219c057df88

うおおお。なんてこったぁ。

とゆーことで、weston-1.3.1が最新（多分今回のバグフィックス入りだ)

http://cgit.freedesktop.org/wayland/weston/snapshot/weston-1.3.1.tar.gz
して、weston-1.3.1をgetだぜ。

su
aptitude build-dep weston/sid
aptitude install libxcb-composite0-dev fakeroot
exit
mkdir weston weston-work
cd weston
apt-get source weston/sid
cd ../weston-work
wget -O weston_1.3.1.orig.tar.gz http://cgit.freedesktop.org/wayland/weston/snapshot/weston-1.3.1.tar.gz
tar xzf ../weston/weston_1.3.0-1.debian.tar.gz
cd debian; patch -p1 < xxxx.patch
tar xzf weston_1.3.1.orig.tar.gz
cd weston-1.3.1
cp -a ../debian .
env DEB_BUILD_OPTIONS='noopt nostrip' dpkg-buildpackage -rfakeroot -us -uc 2>&1 | tee ../build.log
cd ..
su
dpkg -i ./weston


weston-1.3.0-1のパッケージのdebian/をパクったが、
configure側のパッケージ依存で、
libxcb-composite0-dev
が必要だから、debian/controlのbuild-dep:に付け加え。

で、buildしたら、動いたーっ

http://lanyrd.com/topics/x-window-system/slides/
はXの現状がわかって面白い。

waylandが出来た本当の理由
http://people.freedesktop.org/~daniels/lca2013-wayland-x11.pdf
がXに対するdisりっぷりがすげえ。

うは、最小限インストールだと、XDG_RUNTIME_DIRを設定するpamのモジュールを持つ
systemd-logindとか入ってないぜ。
なので、誰が入れてんだかわからんが、XDG_SESSION_COOKIEだけ定義されてる。
codesearch.debian.netでXDG_SESSION_COOKIE調べると、
openssh/consolekitなどでガンガン定義しているようだ。
apt-file search systemd-logindしらべると、systemdだ。

DRM/KMS,FB,V4L2の説明でよい文章↓
http://elinux.org/images/2/22/KMS_FB_and_V4L2_How_to_Select_a_Graphics_and_Video_API.pdf

仮想環境では、一発で動くが、手元のベア環境で何故かsystemd-logindが
動かん。そもそも、このデーモン誰がうごかしてんだ？-->謎

あと、DRM/KMSって、普通に使われてたんだな...知らなかった。
まあ、考えて見たら、汎用品のパソコンなんて、nvidiaかAMDか、intelだもんな、今は。

というわけで、手元のVaioで動かすと、

$ env XDG_RUNNTIME_DIR=/tmp
$ weston-launch

とかするとあっさりweston動いた。
--->さらに凄いことに、ノートPCのVGA端子にも、westonが出力されていた。
　　プレゼンで使えるじゃんかーっ

もすかして、なんもせんでも
weston動くかな...KVMで。
--->ダメだった。

non-freeのnvidiaドライバだと、eglが装備されてないため、mesaのeglが
動き、バグるため、x11-backendの元でちゃんと表示がなされない。

man westonにwayland-backendの件と、XWaylandの使い方出てる。

XWayland対応のXサーバーのパッチは↓
http://lists.debian.org/debian-x/2013/10/msg00205.html
となっているようで、今絶賛開発中？
今はXが -waylandを解釈出来ないのでXサーバーが落ちる落ちる...

ところで、headless-backend.soは動くにゃ動くが、使い方が...よーわからん。

weston --backend=headless-backend.so 
すると待機状態になるので、別にsshした端末から、
env WAYLAND_DISPLAY=wayland-0 weston-terminal
とかすると動くような気配があるが、どうだかよくわからん...

weston付属のモジュールで、
 cms-colord.so
 cms-static.so

があるが、こちらはカラーマネージメントのための
モジュール。実際、cms-colord.soは、

colord
http://www.freedesktop.org/software/colord/intro.html
に接続してカラーマネージメントを行う。
（gnome/kdeだとこれは普通にやる）
※ハードのプロファイルは/usr/share/hwdata/pnp.ids
とか見る。

x11-backend.soでも、--use-pixmanで、pixmanを使い、
デフォルトでは、EGLが利用される。

drmでpixman使ってみたら、やっぱりSEGFaultでおちる。

xkbcommonは別のライブラリだ...
http://xkbcommon.org/

